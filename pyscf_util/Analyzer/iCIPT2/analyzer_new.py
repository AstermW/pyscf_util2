import numpy

import os
from scipy import stats
import matplotlib.pyplot as plt
import numpy as np
import re
from dataclasses import dataclass
from tabulate import tabulate

#### 判断是不是 iCI output file ####


def is_iCI_output(filename):
    """Check if the file is generated by iCI
    Args:
        filename: the name of the file

    Kwargs:

    Returns:
        True or False
    """
    file = open(filename)
    lines = file.readlines()
    # for i in range(min(10, len(lines))):
    for i in range(len(lines)):
        if "Iteractive Configuration Interaction with Selection" in lines[i]:
            return True
    file.close()
    return False


# the follong data class only suitable for 1 nstate calculation #


@dataclass
class iCIPT2_Data:
    ncfg: int
    ncsf: int
    evar: float
    ept: float
    etot: float

    def __str__(self):
        return f"ncfg: {self.ncfg}, ncsf: {self.ncsf}, evar: {self.evar}, ept: {self.ept}, etot: {self.etot}"

    def __gt__(self, other):
        return self.ncsf > other.ncsf


# print #


def print_icipt2_data_table(data_list):
    # 将数据格式化为适合 tabulate 的结构
    table_data = [[d.ncfg, d.ncsf, d.evar, d.ept, d.etot] for d in data_list]

    # 打印表格，设置列名并且内容右对齐
    headers = ["ncfg", "ncsf", "evar", "ept", "etot"]
    print(
        tabulate(
            table_data,
            headers,
            tablefmt="grid",
            stralign="right",
            numalign="right",
            floatfmt="20.8f",
        )
    )


# extract info #


def extract_icipt2_data_from_file(file_path: str):
    with open(file_path, "r") as f:
        lines = f.readlines()

    blocks = []
    in_block = False
    current_block = []

    # -------- 提取 iCI_ENPT(2) block --------
    for line in lines:
        if "iCI_ENPT(2)_NonRela::Info" in line:
            # 遇到新的标题行
            if current_block:
                blocks.append(current_block)
            in_block = True
            current_block = []
            continue

        if in_block:
            # 遇到结束星号行，end block
            if line.strip().startswith("***"):
                blocks.append(current_block)
                in_block = False
                current_block = []
                continue

            current_block.append(line.rstrip("\n"))

    # 最后一个 block
    if in_block and current_block:
        blocks.append(current_block)

    # 供返回的最终结果，按 state 存储
    # key: (spintwo, symmetry, state_index)
    results = {}

    # 正则允许前四列缺失：
    #    spintwo | symmetry | ncfg | ncsf | evar | ept | etot
    pattern = re.compile(
        r"^\s*(\d*)\s*\|\s*(\d*)\s*\|\s*(\d*)\s*\|\s*(\d*)\s*\|\s*([-+]?\d+\.\d+)\s*\|\s*([-+]?\d+\.\d+)\s*\|\s*([-+]?\d+\.\d+)"
    )

    for block in blocks:

        # 找到 header 行位置（包含 evar, ept, etot）
        header_index = None
        for i, line in enumerate(block):
            if "evar" in line and "ept" in line and "etot" in line:
                header_index = i
                break
        if header_index is None:
            continue

        data_lines = block[header_index + 1:]

        state_index = 0
        spintwo_last = None
        symmetry_last = None
        ncfg_last = None
        ncsf_last = None

        for line in data_lines:

            m = pattern.search(line)
            if not m:
                continue

            g = m.groups()

            # 可能为空的字段（第二态以后）
            spintwo = g[0] or spintwo_last
            symmetry = g[1] or symmetry_last
            ncfg = g[2] or ncfg_last
            ncsf = g[3] or ncsf_last

            # 始终存在
            evar = float(g[4])
            ept = float(g[5])
            etot = float(g[6])

            # 储存“上一个态”的完整字段，用于填补后续行缺失值
            spintwo_last = spintwo
            symmetry_last = symmetry
            ncfg_last = ncfg
            ncsf_last = ncsf

            key = (int(spintwo), int(symmetry), state_index)

            if key not in results:
                results[key] = []

            results[key].append(
                iCIPT2_Data(
                    ncfg=int(ncfg),
                    ncsf=int(ncsf),
                    evar=evar,
                    ept=ept,
                    etot=etot
                )
            )

            state_index += 1

    return results


def extract_icipt2_data_from_file2(file_path: str):
    # 读取文件内容
    content = None
    with open(file_path, "r") as file:
        content = file.read()
    # print(content)

    # 正则表达式匹配符合的块和数据

    pattern = r"\*+ iCI_ENPT\(2\)_NonRela::Info \*+\n+_+\n+\s+spintwo\s+\|\s+symmetry\s+\|\s+ncfg\s+\|\s+ncsf\s+\|\s+evar\s+\|\s+ept\s+\|\s+etot\s+.*?\n+"  # title
    pattern += r"\s+(\d+)\s+\|\s+(\d+)\s+\|\s+(\d+)\s+\|\s+(\d+)\s+\|\s+([-+]?\d*\.\d+)\s+\|\s+([-+]?\d*\.\d+)\s+\|\s+([-+]?\d*\.\d+)"  # data

    # 使用正则表达式找到所有符合的数据块
    matches = re.findall(pattern, content)

    # print(matches)

    # 存储匹配到的数据
    extracted_data = []

    # 遍历每个匹配结果，并将其转换为 iCIPT2_Data 对象
    for match in matches:
        data = iCIPT2_Data(
            ncfg=int(match[2]),
            ncsf=int(match[3]),
            evar=float(match[4]),
            ept=float(match[5]),
            etot=float(match[6]),
        )
        extracted_data.append(data)

    return extracted_data


# extra #

from scipy.optimize import curve_fit


def weighted_linear_fit_estimate_error(x, y, print_verbose=False):

    def func(x, a, b):
        return a * x + b

    x = np.asarray(x)
    y = np.asarray(y)

    popt, pcov = curve_fit(func, x, y, sigma=1 / abs(x))

    b = popt[1]
    b_error = np.sqrt(pcov[1][1])

    if print_verbose:
        print("Linear Regression : \n")
        print("Slope             : %16.8e\n" % popt[0])
        print("Intercept         : %16.8e\n" % popt[1])
        print("b_error           : %16.8e\n" % b_error)

    return b, b_error


def quadratic_fit_estimate_error(x, y, print_verbose=False):
    # Define the form of the function we want to fit
    def func(x, a, b, c):
        return a * x**2 + b * x + c

    x = np.asarray(x)
    y = np.asarray(y)

    # Use curve_fit to fit the function to our data. popt will contain the fitted parameters
    popt, pcov = curve_fit(func, x, y)

    # Generate predicted y values from our fitted function
    y_pred = func(x, *popt)

    # Calculate the root mean square error between the predicted and actual y values
    c = popt[2]
    c_error = np.sqrt(pcov[2][2])

    if print_verbose:
        print("Quadratic Regression : \n")
        print("a                 : %15.8f\n" % popt[0])
        print("b                 : %15.8f\n" % popt[1])
        print("c                 : %15.8f\n" % popt[2])
        print("c_error           : %15.8f\n" % c_error)

    return c, c_error


def weighted_quadratic_fit_estimate_error(x, y, print_verbose=False):
    # Define the form of the function we want to fit
    def func(x, a, b, c):
        return a * x**2 + b * x + c

    x = np.asarray(x)
    y = np.asarray(y)

    # Use curve_fit to fit the function to our data. popt will contain the fitted parameters
    popt, pcov = curve_fit(func, x, y, sigma=1 / abs(x))

    # Generate predicted y values from our fitted function
    y_pred = func(x, *popt)

    # Calculate the root mean square error between the predicted and actual y values
    c = popt[2]
    c_error = np.sqrt(pcov[2][2])

    if print_verbose:
        print("Quadratic Regression : \n")
        print("a                 : %15.8f\n" % popt[0])
        print("b                 : %15.8f\n" % popt[1])
        print("c                 : %15.8f\n" % popt[2])
        print("c_error           : %15.8f\n" % c_error)

    return c, c_error


def LinearRegression_EstimateError(x, y, print_verbose=False):

    if len(x) != len(y):
        print("Error Different Length\n")
        return

    t_25 = [
        0,
        12.7062,
        4.3027,
        3.1824,
        2.7764,
        2.5706,
        2.4469,
        2.3646,
        2.3060,
        2.2622,
        2.2281,
        2.2010,
        2.1788,
        2.1604,
        2.1448,
        2.1315,
        2.1199,
    ]
    Mean_x = np.mean(x)
    Mean_y = np.mean(y)
    Sxx = 0
    Syy = 0
    Sxy = 0
    for i in range(len(x)):
        Sxx = Sxx + (x[i] - Mean_x) ** 2
        Syy = Syy + (y[i] - Mean_y) ** 2
        Sxy = Sxy + (x[i] - Mean_x) * (y[i] - Mean_y)
    N = len(x)
    a = stats.linregress(x, y)
    sigma = 0.0
    if N > 2:
        sigma = (1.0 / (N - 2)) * (Syy - a[0] * Sxy)
    sigma = np.sqrt(sigma)
    # print(sigma)
    # print(t_25[N-2])
    b = t_25[N - 2] * sigma * np.sqrt(1.0 / N + Mean_x * Mean_x / Sxx)
    if print_verbose:
        print("Linear Regression : \n")
        print("Slope             : %16.8e\n" % a[0])
        print("Intercept         : %16.8e\n" % a[1])
        print("R Value           : %16.8e\n" % a[2])
        print("R Square          : %16.8e\n" % a[2] ** 2)
        print("0.95 Interval x=0 : %16.8f +- %16.8e\n" % (a[1], b))
    # return [a[0], a[1], a[2]**2, (a[1]-y[-1])*10**6, b, a[2]**2]
    return [a[0], a[1], a[2], b / t_25[N - 2]]


## perform the regression analysis ##


@dataclass
class Regression_Analysis:
    data: list[iCIPT2_Data]
    linear_extra: float
    linear_error: float
    weighted_linear_extra: float
    weighted_linear_error: float
    quadratic_extra: float
    quadratic_error: float
    weighted_quadratic_extra: float
    weighted_quadratic_error: float

    def __str__(self):
        res = "Linear             Regression res %15.8f +- %8.4e" % (
            self.linear_extra,
            self.linear_error,
        )
        res += "\n"
        res += "Weighted Linear    Regression res %15.8f +- %8.4e" % (
            self.weighted_linear_extra,
            self.weighted_linear_error,
        )
        res += "\n"
        res += "Quadratic          Regression res %15.8f +- %8.4e" % (
            self.quadratic_extra,
            self.quadratic_error,
        )
        res += "\n"
        res += "Weighted Quadratic Regression res %15.8f +- %8.4e" % (
            self.weighted_quadratic_extra,
            self.weighted_quadratic_error,
        )
        return res


def extra_icipt2_data(data: list[iCIPT2_Data], npnt: int = 5):
    x = [i.ept for i in data]
    if len(x) > npnt:
        x = x[-npnt:]
    y = [i.etot for i in data]
    if len(y) > npnt:
        y = y[-npnt:]
    _, linear_extra, _, linear_error = LinearRegression_EstimateError(x, y)
    weighted_linear_extra, weighted_linear_error = weighted_linear_fit_estimate_error(
        x, y
    )
    quadratic_extra, quadratic_error = quadratic_fit_estimate_error(x, y)
    weighted_quadratic_extra, weighted_quadratic_error = (
        weighted_quadratic_fit_estimate_error(x, y)
    )
    return Regression_Analysis(
        data,
        linear_extra,
        linear_error,
        weighted_linear_extra,
        weighted_linear_error,
        quadratic_extra,
        quadratic_error,
        weighted_quadratic_extra,
        weighted_quadratic_error,
    )


def print_icipt2_extra(data: Regression_Analysis):
    print_icipt2_data_table(data.data)
    print(data)


if __name__ == "__main__":

    assert is_iCI_output("out.txt")

    blocks = extract_icipt2_data_from_file("out.txt")

    for key, data in blocks.items():
        print("Analyzing state:", key)
        data.sort()
        res = extra_icipt2_data(data)
        print_icipt2_extra(res)

